# 第一章 - 入门

- go 程序答题结构
  - package __packageName__
  - import __package_name__
  - func main(){
  - }
- 起始点
  - main 包 的 main 函数
- 一个目录下的所有go文件对应一个包
- gofmt 代码格式化
- go get下载包
- goimports 管理导入声明的插入和删除

## 语法

- import 声明必须跟在package声明之后.
- import 声明之后是组成程序的函数
- func funcName(param....)(return_value..)
- go 不需要在语句或者声明后面使用分号结尾,除非多个语句或声明在同一行
  - 特殊字符后的换行符被转换为分号 - 特定字符后的换行符不会被转换为分号
    - func 必须和 { 在同一行
    - x+y 这个表达式,换行符可以在 + 后面 ,不可以在+前面
- 每个算术或逻辑运算符都有一个赋值运算符
  - += 
  - 需要操作数具有可赋值性
- 函数和其他包级别的实体可以以任意次序声明
- 指针
  - 值引用
    - &

## 包

- os
  - os.Args 命令行参数
    - 字符串slice 
    - 第0个参数是文件名 , 不一定是绝对路径
- bufio
  - NewScanner(os.stdin)
  - 创建一个input变量来处理标准输入,或者从指定输入来源来的输入
- fmt
  - Printf 
    - 支持转义字符
- io
  - Copy 
    - 把一个流的内容导入另一个流
    - io.Copy(ioutil.Driscard,src)
- ioutil
- http
  - Get
  - Post
  - Client
    - Do
  - HandlerFunc(pattern string , handlerFunc func)

# 第二章 - 程序结构

## 2.1 名称

- 函数,变量,常量,类型,语句标签和包的名称遵循一个简单的规则
  - 名称的开头是一个字母或者下划线
  - 后面可以跟任意数量的字符数字或下划线
  - 区分大小写
  - 关键字不能用作名称
    - break 
    - case chan const continue
    - default defer 
    - else
    - fallthrough for func 
    - go goto 
    - if import interface 
    - map 
    - package 
    - range return 
    - select struct switch
    - type 
    - var
  - 预声明的常量,类型和函数
    - 常量
      - true false iota nil
    - 类型
      - int int8 int16 int32 int64  uint uint8 uint16  uint32 uint64 uintptr
      - float32 float64 complex128 complex64 
      - bool byte rune string error
    - 函数
      - make len cap new append copy close delete complex real imag panic recover
  - 作用域
    - 代码块中的声明仅对代码块内部可见
      - for 初始化部分产生的变量
    - 函数内声明的实体旨在函局部有效(除非该对象被return出去) 
    - 包级别的实体在对包内的所有源文件可见,是否跨包取决于首字母是否大写

## 2.2 声明

- 声明给一个实体命名,并设定其部分或全部属性.
  - 四种声明
    - 变量(var)
    - 常量(const)
    - 类型(type)
    - 函数(func)
      - 包含 名字 参数列表 可选的返回值列表 和 函数体

## 2.3 变量

- var 声明创建一个具体类型的变量,然后附加给他一个名字并设置它的初始值
  - var name type = expression
  - type 和 expression 可以省略一个但不能都省略
    - type 省略时根据expression 确定类型
    - expression 省略时使用对应 type 的零值作为初始值
      - expression 可以是有返回值的函数调用
- 零值机制
  - 数字 - 0
  - bool - false
  - 字符串 - ""
  - 接口或者引用类型(silce , 指针 , map , 通道 , 函数) - nil
  - 数组或结构体这样的符合类型 - 所有元素或成员的零值 

### 2.3.1 短变量声明

- 在__函数__中,一种被称作__短变量声明__的可选性是可以用来声明和初始化局部变量.
  - name := expression
- 什么时候用var
  - 在声明类型和初始化表达式的结果不一致的变量时
  - 初始值不重要的变量时
  - 赋值点在后面的处理过程中
- 短变量声明支持多变量声明
- 对于一些在同一个词法块中已经被声明过的变量,短变量声明只会起到赋值的作用

- 短变量声明至少声明一个新变量

### 2.3.2 指针

- 指针的值是一个变量的地址,指针指向值保存的位置
- 所有变量都有地址,但是不是所有的值都有地址
- 使用指针可以在无需知道变量名字的情况下读写变量的值
- & 取地址符
- \* 获取变量的值 - 指针也有对应的类型
- 指针可比较,且有零值(nil - 等于nil时该指针不指向任何一个变量)
  - 在指向同一个变量时,指针的值相等
- 修改指针对应的变量时,也需要修改所有与之相关的指针的调用
- 指针对于flag包的使用很关键
  - flag.Bool 这一类函数调用返回的是对应类型的指针
  - 需要通过 *name 来获取对应命令行参数的值
  - 在使用对应变量前,需要通过 flag.Parse 来更新对应变量的值

### 2.3.3 new 函数

- new函数可以创建一个未命名的 T 类型变量 , 返回值为对应类型的指针
  - var ptrName = new(T)
- new 与 普通局部变量的取地址的区别在于不会引入一个虚拟的名字
- 每次调用new返回不一样的地址
  - 例外
    - struct{} 与 [0]int (低版本)

### 2.3.4 变量的生命周期

- 生命周期是指在程序执行过程中变量存在的时间段.

- 包级别变量的生命周期是整个程序的执行时间
- 局部变量有一个动态的生命周期
  - 每次执行声明语句创建一个新的实体
  - 变量一直生存道它变得不可访问,这时它占用的存储空间被回收
  - 函数的参数和返回值也是局部变量,它们在其闭包函数被调用的时候创建
  - 因为变量的生命周期根据是否可访问来判断,所以循环内的局部变量在被外部的指针引用后,可以在循环结束后存在
- go 分配变量使用栈空间还是堆空间是根据变量是否从函数空间中逃逸,如果函数返回后还可以访问,即使用堆空间来分配

## 2.4 赋值

- 赋值 用来更新变量所指的值
  - 变量 = expression
- 每个算术和二进制位操作符有一个对应的赋值操作符,可以避免重复变量本身
  - count[x] = count[x] * scale
  - count[x] *= scale
- 数字变量可以通过 ++ 或者 -- 进行递增或递减

### 2.4.1 多重赋值

- 允许几个变量一次性被赋值
  - 在实际更新变量前,右边所有的表达式被推演
  - 在变量同时出现在两边时比较有意义

### 可赋值性

- 赋值语句是显式赋值,还存在许多的隐式赋值
  - 调用函数时,将参数的值赋值给对应参数的变量
  - return 时赋值给对应的变量
  - 结构体或者数组语句定义时对每一个元素进行赋值
- 可赋值性如何判断
  - 根据类型做区分
    - 基础类型
      - 类型必须精准匹配
      - nil 可以被赋值给任何接口或者引用类型
      - 常量有更灵活的可赋值性规则
    - 新类型
      - 在引入时解释其可赋值性
- == 和 != 比较也与可赋值性相关,两边必须可赋值才可比较

## 2.5 类型声明

- 基于一个底层类型 定义一个新的类型
  - type name underlying-type
- 通过划分新的类型可以在支持相同的操作的同时,划分出不同的概念,从而提高程序的可读性,并且降低一些错误的可能
- T(x)
  - 类型转换,在底层类型相同的情况下或者具有可赋值性的情况下 , 可以将x的类型转换为T
  - 通常情况下不改变值的表达方式,仅改变类型
    - 在浮点数转换为整数时,会丢失小数部分
    - 字符串转换为字节([]byte)slice时会分配一份字符串数据副本
- 可以通过定义 func(c T)String() string 来获得指定的字符串输出

## 2.6 包

- go 使用包来完成模块化,封装,编译隔离和重用.
- 一个或多个以.go结尾的文件组成一个包
- 从gopath/src 开始的目录名是导入路径 . 最后一段是包的名称
- 每个包有独立的命名空间,通过不同的修饰标识符来指明对应的对象
- 通过空间变量在包外的可见性或导出情况来隐藏信息(大写开头)
- package 声明前的注释是对整个包的描述

### 2.6.1 导入

- (包名) 导入路径
  - 包名是导入路径的短名称,可选,按约定是导入路径的最后一段
- 导入一个没有引用的包会导致报错

### 2.6.2 包初始化

- 多个文件组成
  - 初始化按照收到文件的顺序惊醒
  - go 编译器调用前会先对.go文件进行排序

- 包初始化的顺序 
  - 依赖
    - 自下而上的完成依赖包的初始化
  - 初始化包级别的变量
    - 按照声明顺序
    - 生命周期从其被初始化开始
  - init函数
    - func init()

## 2.7 作用域

- 声明将一个名字与目标实体关联起来

- 声明的作用域与生命周期不同
  - 作用域是指声明的名字在源代码中出现的范围
  - 生命周期是指名字对应的实体的在执行期间能被其他部分引用的范围
- 语法块(block) , 词法块 和 全局快
  - 语法块
    - 显式的词法块,有明确的大括号包裹
  - 词法块
    - 包含一部分隐式的词法块
      - 循环初始化 - 条件 - 迭代等部分
      - switch case
      - if else
  - 全局块
    - 包含了全部源代码的词法块
- 内置类型,函数或常量在全局块中声明对整个程序可见
- 包级别的声明可以被包内的所有引用
- 导入的包是文件级别 - 只能在当前文件中引用
- 局部声明, 仅在对应的词法块中可见
- 内层声明会覆盖外层声明,暂时覆盖外层声明的可见性

# 第三章 基本数据

- go 数据类型
  - 基础类型(basic type)
  - 聚合类型(aggregate type)
  - 引用类型(reference type)
  - 接口类型(interface type)
- 本章主题是基本类型,包括数字(number),字符串(string)和布尔型(boolean)
  - 聚合类型 - 数组或者结构体是由多个基础类型组合而成的
  - 引用类型 - 指针(pointer) , slice  , map , 函数(function) 以及通道(channel),它们的共同点是全都指向程序变量或状态
    - 所以操作所引用的数据,效果会遍及全部引用

## 3.1 整数

- 整数按照位数来划分有 (u)int8 , (u)int16, (u)int32 , (u)int64 
  - 数字代表位数 (u)int8 , 8位
  - 是否加 u 代表是有符号数还是无符号数
  - 有符号数的最高位保留为符号位,所以有符号数表示的数字范围比无符号数小一个2进制级别
    - 有符号数
      - -2^(n-1) -> 2^(n-1) - 1
    - 无符号数
      - 0 -> 2^n - 1
- (u)int 大小不固定,表示特定平台上运算效率最高的值,通常是32位或者64位
- rune 是 int32 的同义词,用来强调数据是unicode码点
  - byte 是 uint8 的同义词,用来强调是原始数据
- uintptr 大小不明确,但是足以完整存放指针,该类型仅用于底层编程
- 操作符
  - 二元操作符分为5大优先级,同级别的运算符满足左结合律,为求清晰,可能需要圆括号来使表达式按照想法计算
  - 操作符两边需要类型相同
  - % 仅能用于 整数,取模余数的正负号和被除数一致.
  - / 整数相除会舍弃小数部分
  - \- \+ 一元加减法可以表示一个变量的正负 , 等同于 0 +/- x
- 位运算符号
  - &(and) |(or) ^(xor) &^(位清空 and not)  << (左移) >> (右移)
  - 有符号数的右移操作以符号位的数字补齐,无符号数以0补齐
  - << n 等于 * 2^n , >> n 等于 / 2^n
- 类型不匹配,强制类型转换 
  - 代价是不同位数的变换可能会损失数据的精度
  - 浮点型转为整形会舍弃小数部分,趋零截尾